---
title: "[Node.js 교과서] Node.js의 기능"
date: 2023-04-05
categories:
  - \lectures
tags:
  - node.js
  - Node.js 교과서
  - 조현영(zerocho)
---

## 제 3장. 노드 기능 알아보기

### 1) 모듈

- CommonJS 모듈

  ```js
  // 파일 하나당 하나만 가능
  module.exports = 데이터;
  // 파일 하나당 여러개 가능
  exports.변수 = 데이터;
  ```

  ```js
  const 데이터 = require("경로");
  // require.main은 실행한 파일
  // require.cache는 캐시된 모듈(한 번 이상 실행된 경우)
  // 순환 참조 시 자동으로 빈 객체가 됨
  ```

- ECMAScript 모듈

  ```js
  // 이름 필수 X, 파일 하나당 하나만 가능
  export default 데이터
  // 이름 필수 O, 파일 하나당 여러개 가능
  export 데이터
  ```

  ```js
  // export default
  import 임의_데이터명 from "경로";
  // export
  import { 데이터명 } from "경로";
  import { 데이터명 as 임의_데이터명 } from "경로";
  import * as 임의_객체명 from "경로";
  ```

- CommonJS 모듈과 ES 모듈의 차이점

  | 차이점                        | CommonJS 모듈 | ES 모듈                                               |
  | ----------------------------- | ------------- | ----------------------------------------------------- |
  | 최상단 외 사용                | 가능          | 불가능                                                |
  | 확장자                        | js, cjs       | js(package.json에 "type": "module" 필요), mjs         |
  | 확장자 생략                   | 가능          | 불가능                                                |
  | 인덱스 생략                   | 가능          | 불가능                                                |
  | top level await<sup>[1]</sup> | 불가능        | 가능                                                  |
  | dynamic import<sup>[2]</sup>  | 가능          | 불가능                                                |
  | `__filename`,<br/>`__dirname` | 사용 가능     | 사용 불가능(\_\_filename 대신 `import.meta.url` 사용) |

  <sup>[1]</sup> top level await: 최상위 스코프에서 await 바로 사용 가능

  <sup>[2]</sup> dynamic import

  ```cjs
  const a = true;
  if (a) require("...");
  ```

  ```mjs
  const a = true
  if (a) const b = await import("...")
  ```

  \*CommonJS 모듈과 ES 모듈 간의 호출은 대부분 가능

  \*최상위 스코프의 this는 module.exports

  ```js
  console.log(this); // -> {}
  ```

### 2) 노드 내장 객체

1. global

   - 노드의 전역 객체
   - 브라우저의 window(globalThis)와 같은 역할
   - global에 값을 넣을 경우 다른 파일에서도 사용 가능하지만 지양해야함

2. console

   | Methods                                       | Details                                  |
   | --------------------------------------------- | ---------------------------------------- |
   | console.time(로그),<br/>console.timeEnd(로그) | 시간 로깅                                |
   | console.log(로그)                             | 시간 로깅                                |
   | console.table(로그)                           | 테이블로 표시되는 로깅                   |
   | console.error(로그)                           | 에러 로깅                                |
   | console.dir(로그)                             | 객체 로깅                                |
   | console.trace(로그)                           | 호출스택 로깅<br/>_\*함수 내부에서 사용_ |

    <details>
    <summary>example</summary>
    <div markdown=1>

   ```js
   const string = "abc";
   const number = 1;
   const boolean = true;
   const obj = {
     outside: {
       inside: {
         key: "value",
       },
     },
   };
   console.time("전체시간");
   console.log("평범한 로그입니다 쉼표로 구분해 여러 값을 찍을 수 있습니다");
   console.log(string, number, boolean);
   console.error("에러 메시지는 console.error에 담아주세요");

   console.table([
     { name: "제로", birth: 1994 },
     { name: "hero", birth: 1988 },
   ]);

   console.dir(obj, { colors: true, depth: 2 });
   console.dir(obj, { colors: false, depth: 1 });

   console.time("시간측정");
   for (let i = 0; i < 100000; i++) {}
   console.timeEnd("시간측정");

   function b() {
     console.trace("에러 위치 추적");
   }
   function a() {
     b();
   }
   a();

   console.timeEnd("전체시간");
   ```

   ```bash
   평범한 로그입니다 쉼표로 구분해 여러 값을 찍을 수 있습니다
   abc 1 true
   에러 메시지는 console.error에 담아주세요
   ┌─────────┬────────┬───────┐
   │ (index) │  name  │ birth │
   ├─────────┼────────┼───────┤
   │    0    │ '제로'  │ 1994  │
   │    1    │ 'hero' │ 1988  │
   └─────────┴────────┴───────┘
   { outside: { inside: { key: 'value' } } }
   { outside: { inside: [Object] } }
   시간측정: 21.228ms
   Trace: 에러 위치 추적
       at b (/Users/yuchanjeong/Desktop/nodejs-book-master/ch3/3.4/console.js:29:11)
       at Object.<anonymous> (/Users/yuchanjeong/Desktop/nodejs-book-master/ch3/3.4/console.js:32:1)
       at Module._compile (node:internal/modules/cjs/loader:1155:14)
       at Object.Module._extensions..js (node:internal/modules/cjs/loader:1209:10)
       at Module.load (node:internal/modules/cjs/loader:1033:32)
       at Function.Module._load (node:internal/modules/cjs/loader:868:12)
       at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)
       at node:internal/main/run_main_module:22:47
   전체시간: 34.557ms
   ```

    </div>
    </details>

3. process

   - 현재 실행중인 노드 프로세스에 대한 정보를 담고있음

   | Properties & Methods   | Details                                                                                                                                                                             |
   | ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | process.cwd()          | 실행중인 노드 프로세스 경로                                                                                                                                                         |
   | process.env            | 시스템 환경 변수<br/>_\*노드에 직접 영향을 미치는 변수도 있음_<br/>ㅤ*NODE_OPTIONS=--max-old-space-size=8192 (노드 옵션: 메모리 사이즈)*<br/>ㅤ*UV_THREADPOOL_SIZE=8 (스레드 갯수)* |
   | process.nextTick(콜백) | 이벤트 루프가 다른 콜백함수 보다 우선적으로 처리                                                                                                                                    |
   | process.exit(코드)     | 코드가 없거나 0이면 정상 종료<br>_\*그 외는 비정상 종료_                                                                                                                            |

    <details>
    <summary>example</summary>
    <div markdown=1>

   ```bash
   $ node
   > process.version
   v18.7.0 // 설치된 노드의 버전입니다
   > process.arch
   x64 // 프로세서 아키텍처 정보입니다. arm, ia32 등의 값일 수도 있습니다
   > process.platform
   win32 // 운영체제 플랫폼 정보입니다. linux나 darwin, freebsd 등의 값일 수도 있습니다
   > process.pid
   14736 // 현재 프로세스의 아이디입니다. 프로세스를 여러 개 가질 때 구분할 수 있습니다
   > process.uptime()
   199.36 // 프로세스가 시작된 후 흐른 시간입니다. 단위는 초입니다
   > process.execPath
   C:\Program Files\nodejs\node.exe // 노드의 경로입니다
   > process.cwd()
   C:\Users\zerocho // 현재 프로세스가 실행되는 위치입니다
   > process.cpuUsage()
   { user: 390000, system: 203000 } // 현재 cpu 사용량입니다
   ```

    </div>
    </details>

4. 기타 내장 객체

   - URL, URLSearchParams
   - TextDecoder: Buffer를 문자열로 바꿈
   - TextEncoder: 문자열을 Buffer로 바꿈
   - WebAssembly: 웹어셈블리 처리 담당
   - AbortController, FormData, fetch, Headers, Request, Response, Event, EventTarget: 브라우저에서 사용하던 API들

### 3) 노드 내장 모듈

#### 1. os (●○○)

- 운영체제의 정보를 담고있는 모듈

    <details>
    <summary>list</summary>
    <div markdown=1>

  - os.arch(): process.arch와 동일합니다.
  - os.platform(): process.platform과 동일합니다.
  - os.type(): 운영체제의 종류를 보여줍니다.
  - os.uptime(): 운영체제 부팅 이후 흐른 시간(초)을 보여줍니다.
  - os.hostname(): 컴퓨터의 이름을 보여줍니다.
  - os.release(): 운영체제의 버전을 보여줍니다.
  - os.homedir(): 홈 디렉터리 경로를 보여줍니다.
  - os.tmpdir(): 임시 파일 저장 경로를 보여줍니다.
  - <strong>os.cpus()</strong>: 컴퓨터의 코어 정보를 보여줍니다.
  - os.freemem(): 사용 가능한 메모리(RAM)를 보여줍니다.
  - os.totalmem(): 전체 메모리 용량을 보여줍니다.

    </div>
    </details>

#### 2. path (●●○)

- 폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈
- `path.join(경로, …)` vs `path.resolve(경로, …)`

  ```js
  path.join("/a", "/b", "c"); /* 결과: /a/b/c/ */
  path.resolve("/a", "/b", "c"); /* 결과: /b/c */
  ```

| Properties & Methods              | Return                                                                                                                        |
| --------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| path.sep                          | 경로의 구분자<br/>_\*WINDOW는 "\\", POSIX(LINUX & MAC)는 "/"_                                                                 |
| path.delimiter                    | 환경 변수의 구분자 (process.env.PATH를 입력하면 여러 개의 경로가 이 구분자로 구분되어 있음)<br/>_\*WINDOW는 ";", POSIX는 ":"_ |
| path.dirname(경로)                | 파일이 위치한 폴더 경로                                                                                                       |
| path.extname(경로)                | 파일의 확장자                                                                                                                 |
| path.basename(경로, [확장자])     | 파일의 이름<br/>_\*두 번째 인수를 넣을 경우 파일의 이름만 표시_                                                               |
| path.parse(경로)                  | 파일 경로를 root, dir, base, ext, name으로 구분한 객체                                                                        |
| path.format(객체)                 | path.parse()의 반환값을 합친 경로                                                                                             |
| path.normalize(경로)              | "/"나 "\\"를 잘못 사용했을 때 올바르게 변환한 경로                                                                            |
| path.isAbsolute(경로)             | 절대경로인지 여부                                                                                                             |
| path.relative(기준경로, 목표경로) | 기준경로에서 목표경로로 가는 경로                                                                                             |

<details>
<summary>example</summary>
<div markdown=1>

```js
const path = require('path');

const string = __filename;

console.log('path.sep:', path.sep);
console.log('path.delimiter:', path.delimiter);
console.log('------------------------------');
console.log('path.dirname():', path.dirname(string));
console.log('path.extname():', path.extname(string));
console.log('path.basename():', path.basename(string));
console.log('path.basename - extname:', path.basename(string, path.extname(string)));
console.log('------------------------------');
console.log('path.parse()', path.parse(string));
console.log('path.format():', path.format({
dir: 'C:\users\zerocho',
name: 'path',
ext: '.js',
}));
console.log('path.normalize():', path.normalize('C://users\\zerocho\\path.js'));
console.log('------------------------------');
console.log('path.isAbsolute(C:\):', path.isAbsolute('C:\'));
console.log('path.isAbsolute(./home):', path.isAbsolute('./home'));
console.log('------------------------------');
console.log('path.relative():', path.relative('C:\users\zerocho\path.js', 'C:\'));
console.log('path.join():', path.join(__dirname, '..', '..', '/users', '.', '/zerocho'));
console.log('path.resolve():', path.resolve(__dirname, '..', 'users', '.', '/zerocho'));
```

```bash
path.sep: \
path.delimiter: ;
------------------------------
path.dirname(): C:\Users\zerocho
path.extname(): .js
path.basename(): path.js
path.basename - extname: path
------------------------------
path.parse() {
root:  'C:\',
dir:  'C:\Users\zerocho',
base:  'path.js',
ext:  '.js',
name:  'path'
}
path.format(): C:\users\zerocho\path.js
path.normalize(): C:\users\zerocho\path.js
------------------------------
path.isAbsolute(C:\): true
path.isAbsolute(./home): false
------------------------------
path.relative(): ..\..\..
path.join(): C:\Users\zerocho
path.resolve(): C:\zerocho
```

</div>
</details>

#### 3. url (●●○)

- 인터넷 주소를 쉽게 조작하도록 도와주는 모듈
- pathname만 있는 주소는 `new URL(pathname, host)`로 host를 두 번째 인수로 적어줘야 함
- `.searchParams`로 쿼리 스트링을 다룸
|Methods | Return or Details|
|---|---|
|.searchParams.getAll(키)|키에 해당하는 모든 값|
|.searchParams.get(키)|키에 해당하는 첫 번째 값|
|.searchParams.has(키)|해당 키의 존재 여부|
|.searchParams.keys()|모든 키를 포함한 iterator(반복자 객체)|
|.searchParams.values()|모든 값를 포함한 iterator(반복자 객체)|
|.searchParams.append(키, 값)|해당 키를 추가, 같은 키의 값이 있다면 유지하면서 하나 더 추가|
|.searchParams.set(키, 값)|해당 키를 제거|
|.searchParams.toString()|조작한 searchParams 객체를 다시 문자열로 만듦|
<details>
<summary>example</summary>
<div markdown=1>

<img width="800px" src="/assets/lectures/Node.js 교과서/WHATWG.png" alt="https://thebook.io/080334/0122/"/>

```js
const myURL = new URL(
  "http://www.gilbut.co.kr/book/bookList.aspx?sercate1=001001000#anchor"
);
console.log("new URL():", myURL);
console.log("url.format():", url.format(myURL));
```

```bash
new URL(): URL {
  href: 'http://www.gilbut.co.kr/book/bookList.aspx?sercate1=001001000#anchor',
  origin: 'http://www.gilbut.co.kr',
  protocol: 'http:',
  username: '',
  password: '',
  host: 'www.gilbut.co.kr',
  hostname: 'www.gilbut.co.kr',
  port: '',
  pathname: '/book/bookList.aspx',
  search: '?sercate1=001001000',
  searchParams: URLSearchParams { 'sercate1' => '001001000' },
  hash: '#anchor'
}
url.format(): http://www.gilbut.co.kr/book/bookList.aspx?sercate1=001001000#anchor
```

```js
const myURL = new URL(
  "http://www.gilbut.co.kr/?page=3&limit=10&category=nodejs&category=javascript"
);
console.log("searchParams:", myURL.searchParams);
console.log("searchParams.getAll():", myURL.searchParams.getAll("category"));
console.log("searchParams.get():", myURL.searchParams.get("limit"));
console.log("searchParams.has():", myURL.searchParams.has("page"));

console.log("searchParams.keys():", myURL.searchParams.keys());
console.log("searchParams.values():", myURL.searchParams.values());

myURL.searchParams.append("filter", "es3");
myURL.searchParams.append("filter", "es5");
console.log(myURL.searchParams.getAll("filter"));

myURL.searchParams.set("filter", "es6");
console.log(myURL.searchParams.getAll("filter"));

myURL.searchParams.delete("filter");
console.log(myURL.searchParams.getAll("filter"));

console.log("searchParams.toString():", myURL.searchParams.toString());
myURL.search = myURL.searchParams.toString();
```

```bash
searchParams: URLSearchParams {
  'page' => ' 3 ',
  'limit' => ' 10 ',
  'category' => 'nodejs',
  'category' => 'javascript' }
searchParams.getAll(): [ 'nodejs', 'javascript' ]
searchParams.get(): 10
searchParams.has(): true
searchParams.keys(): URLSearchParams Iterator { 'page', 'limit', 'category', 'category' }
searchParams.values(): URLSearchParams Iterator { ' 3 ', ' 10 ', 'nodejs', 'javascript' }
[ 'es 3 ', 'es 5 ' ]
[ 'es 6 ' ]
[]
searchParams.toString(): page=3&limit=10&category=nodejs&category=javascript
```

</div>
</details>

#### 4. dns (●○○)

- DNS를 다룰 때 사용하는 모듈
- 도메인을 통해 IP나 DNS 레코드를 얻고자 할 때 사용
- 레코드
  - A(ipv4 주소), AAAA(ipv6 주소), NS(네임서버), SOA(도메인 정보), CNAME(별칭, 주로 www가 붙은 주소), MX(메일 서버)

<details>
<summary>example</summary>
<div markdown=1>

```js
import dns from "dns/promises";

const ip = await dns.lookup("gilbut.co.kr");
console.log("IP", ip);

const a = await dns.resolve("gilbut.co.kr", "A");
console.log("A", a);

const mx = await dns.resolve("gilbut.co.kr", "MX");
console.log("MX", mx);

const cname = await dns.resolve("www.gilbut.co.kr", "CNAME");
console.log("CNAME", cname);

const any = await dns.resolve("gilbut.co.kr", "ANY");
console.log("ANY", any);
```

```bash
IP { address: ' 49 . 236 . 151 . 220 ', family: 4 }
A [ ' 49 . 236 . 151 . 220 ' ]
MX [
  { exchange: 'alt 2 .aspmx.l.google.com', priority: 5 },
  { exchange: 'aspmx 3 .googlemail.com', priority: 10 },
  { exchange: 'aspmx 2 .googlemail.com', priority: 10 },
  { exchange: 'aspmx.l.google.com', priority: 1 },
  { exchange: 'alt 1 .aspmx.l.google.com', priority: 5 }
]
CNAME [ 'slb- 1088813 .ncloudslb.com' ]
ANY [
  { address: ' 49 . 236 . 151 . 220 ', ttl: 14235, type: 'A' },
  { value: 'ns 1 - 2 .ns-ncloud.com', type: 'NS' },
  { value: 'ns 1 - 1 .ns-ncloud.com', type: 'NS' },
  {
    nsname: 'ns 1 - 1 .ns-ncloud.com',
    hostmaster: 'ns 1 - 2 .ns-ncloud.com',
    serial: 32,
    refresh: 21600,
    retry: 1800,
    expire: 1209600,
    minttl: 300,
    type: 'SOA'
  }
]
```

</div>
</details>

#### 5. crypto (●○○)

- 다양한 방식의 암호화를 도와주는 모듈

1.  단방향 암호 - 암호화는 가능하지만 복호화는 불가능, `Hash`

    - 문자열을 고정된 길이의 다른 문자열로 바꾸는 방식
    - 출력 문자열이 같은 경우 충돌이 발생했다고 함
      | Methods | Details |
      | --------------------- | ----------------------------------------------------------------------------------------------------------------------- |
      | .createHash(해시 알고리즘) | ~~md5~~, ~~sha1~~, ~~sha256~~, sha512등의 사용할 해시 알고리즘을 넣음<br/>_\*보안 취약점이 많이 발견 되면서 현재는 pbkdf2, bcrypt, scrypt등의 방식을 사용_<br/>_\*노드는 pbkdf2와 scrypt 지원_ |
      | -.update(문자열) | 변환할 문자열을 넣음 |
      | -.digest(인코딩) | `base64`, hex, latin1등의 인코딩할 알고리즘을 넣음 |
    - pbkdf2

      - 기존 문자열에 salt(문자열)를 붙인 후 해시 알고리즘을 반복해서 적용하는 방식
      - params: 비밀번호, salt, 반복 횟수, 출력 바이트, 해시 알고리즘

    <details>
    <summary>example</summary>
    <div markdown=1>

    ```js
    const crypto = require("crypto");

    console.log(
      "base64:",
      crypto.createHash("sha512").update("비밀번호").digest("base64")
    ); // 가장 짧음
    console.log(
      "hex:",
      crypto.createHash("sha512").update("비밀번호").digest("hex")
    );
    console.log(
      "base64:",
      crypto.createHash("sha512").update("다른 비밀번호").digest("base64")
    );
    ```

    ```js
    const crypto = require("crypto");

    // randomBytes이므로 매번 실행할 때마다 결과가 달라져서 salt를 잘 보관하고 있어야 비밀번호도 찾을 수 있음
    crypto.randomBytes(64, (err, buf) => {
      const salt = buf.toString("base64");
      console.log("salt:", salt);
      crypto.pbkdf2("비밀번호", salt, 100000, 64, "sha512", (err, key) => {
        console.log("password:", key.toString("base64"));
      });
    });
    ```

    </div>
    </details>

2.  양방향 암호 - 암호화된 문자열을 키로 복호화할 수 있음

    1. 대칭형 암호 - 같은 키
    1. 비대칭 암호 - 다른 키 (e.g. https)

    <details>
    <summary>example</summary>
    <div markdown=1>

    ```js
    const crypto = require("crypto");

    const algorithm = "aes-256-cbc";
    const key = "abcdefghijklmnopqrstuvwxyz123456";
    const iv = "1234567890123456";

    const cipher = crypto.createCipheriv(algorithm, key, iv);
    let result = cipher.update("암호화할 문장", "utf8", "base64");
    result += cipher.final("base64");
    console.log("암호화:", result);

    const decipher = crypto.createDecipheriv(algorithm, key, iv);
    let result2 = decipher.update(result, "base64", "utf8");
    result2 += decipher.final("utf8");
    console.log("복호화:", result2);
    ```

    </div>
    </details>

    _\*키는 AWS kms등으로 잘 관리해 줘야 함_

#### 6. util (●○○)

- 각종 편의 기능을 모아둔 모듈

| Methods                      | Details                                                                    |
| ---------------------------- | -------------------------------------------------------------------------- |
| util.deprecate(콜백, 메시지) | 함수가 deprecated 처리되었음을 알림                                        |
| util.promisify(콜백)         | 콜백 패턴을 프로미스 패턴으로 변경(but 콜백이 "(err, data) => {}" 여야 함) |

<details>
<summary>example</summary>
<div markdown=1>

```js
const util = require("util");
const crypto = require("crypto");

const dontUseMe = util.deprecate((x, y) => {
  console.log(x + y);
}, "dontUseMe 함수는 deprecated되었으니 더 이상 사용하지 마세요!");
dontUseMe(1, 2);

const randomBytesPromise = util.promisify(crypto.randomBytes);
randomBytesPromise(64)
  .then((buf) => {
    console.log(buf.toString("base64"));
  })
  .catch((error) => {
    console.error(error);
  });
```

```bash
3
(node:7264) DeprecationWarning: dontUseMe 함수는 deprecated되었으니 더 이상 사용하지 마세요!
(Use `node --trace-deprecation ...` to show where the warning was created)
60b4RQbrx1j130x4r95fpZac9lmcHyitqwAm8gKsHQKF8tcNhvcTfW031XaQqHlRKzaVkcENmIV25fDVs3SB7g==
```

</div>
</details>

#### 7. worker_threads (●○○)

- 노드에서 멀티 스레드를 다루기 위해 사용하는 모듈
- 스레드를 생성하고 스레드 사이에서 통신하는 데 상당한 비용이 발생하기 때문에 주의가 필요

<details>
<summary>example</summary>
<div markdown=1>

- 동작 예제

  ```js
  const {
    Worker,
    isMainThread,
    parentPort,
    workerData,
  } = require("worker_threads");

  if (isMainThread) {
    // 부모일 때
    const threads = new Set();
    threads.add(
      new Worker(__filename, {
        workerData: { start: 1 },
      })
    );
    threads.add(
      new Worker(__filename, {
        workerData: { start: 2 },
      })
    );
    for (let worker of threads) {
      worker.on("message", (message) => console.log("from worker", message));
      worker.on("exit", () => {
        threads.delete(worker);
        if (threads.size === 0) {
          console.log("job done");
        }
      });
    }
  } else {
    // 워커일 때
    const data = workerData;
    parentPort.postMessage(data.start + 100);
  }
  ```

  ```bash
  from worker 101
  from worker 102
  job done
  ```

- 소수 찾기 예제

  ```js
  const {
    Worker,
    isMainThread,
    parentPort,
    workerData,
  } = require("worker_threads");

  const min = 2;
  let primes = [];

  function findPrimes(start, range) {
    let isPrime = true;
    const end = start + range;
    for (let i = start; i < end; i++) {
      for (let j = min; j < Math.sqrt(end); j++) {
        if (i !== j && i % j === 0) {
          isPrime = false;
          break;
        }
      }
      if (isPrime) {
        primes.push(i);
      }
      isPrime = true;
    }
  }

  if (isMainThread) {
    const max = 10000000;
    const threadCount = 8;
    const threads = new Set();
    const range = Math.floor((max - min) / threadCount);
    let start = min;
    console.time("prime");
    for (let i = 0; i < threadCount - 1; i++) {
      const wStart = start;
      threads.add(
        new Worker(__filename, { workerData: { start: wStart, range } })
      );
      start += range;
    }
    threads.add(
      new Worker(__filename, { workerData: { start, range: max - start } })
    );
    for (let worker of threads) {
      worker.on("error", (err) => {
        throw err;
      });
      worker.on("exit", () => {
        threads.delete(worker);
        if (threads.size === 0) {
          console.timeEnd("prime");
          console.log(primes.length);
        }
      });
      worker.on("message", (msg) => {
        primes = primes.concat(msg);
      });
    }
  } else {
    findPrimes(workerData.start, workerData.range);
    parentPort.postMessage(primes);
  }
  ```

</div>
</details>

#### 8. child_process (●○○)

- 노드에서 다른 프로그램을 실행하고 싶거나 명령어를 수행하고 싶을 때 사용하는 모듈
- exec
  - 셸을 실행해서 명령어를 수행
  - stdout을 버퍼로 리턴(정확히는 콜백을 호출)
- spawn
  - 새로운 프로세스를 띄우면서 명령어를 실행
  - stdout을 스트림으로 리턴
    - 중간에 출력에 맞춰서 입력을 바꿔 넣을 수 있음
  - 첫 번째 인수로 명령어, 두 번째 인수로 옵션 배열
  - 세 번째 인수로 { shell: true }를 제공하면 exec처럼 셸을 실행해서 명령어를 수행

<details>
<summary>example</summary>
<div markdown=1>

- exec

  ```js
  const exec = require("child_process").exec;

  const process = exec("ls");

  process.stdout.on("data", function (data) {
    console.log("data:", data.toString());
  }); // 실행 결과

  process.stderr.on("data", function (data) {
    console.error("error: ", data.toString());
  }); // 실행 에러
  ```

- spawn

  ```js
  const spawn = require("child_process").spawn;

  const process = spawn("python", ["test.py"]);

  process.stdout.on("data", function (data) {
    console.log(data.toString());
  }); // 실행 결과

  process.stderr.on("data", function (data) {
    console.error(data.toString());
  }); // 실행 에러
  ```

</div>
</details>

#### 9. 기타 모듈

- async_hooks: 비동기 코드의 흐름을 추적할 수 있는 실험적인 모듈입니다.
- dgram: UDP와 관련된 작업을 할 때 사용합니다.
- net: HTTP보다 로우 레벨인 TCP나 IPC 통신을 할 때 사용합니다.
- perf_hooks: 성능 측정을 할 때 console.time보다 더 정교하게 측정합니다.
- querystring: URLSearchParams가 나오기 이전에 쿼리스트링을 다루기 위해 사용했던 모듈입니다. 요즘은 URLSearchParams를 사용하는 것을 권장합니다.
- string_decoder: 버퍼 데이터를 문자열로 바꾸는 데 사용합니다.
- tls: TLS와 SSL에 관련된 작업을 할 때 사용합니다.
- tty: 터미널과 관련된 작업을 할 때 사용합니다.
- v8: v8 엔진에 직접 접근할 때 사용합니다.
- vm: 가상 머신에 직접 접근할 때 사용합니다.
- wasi: 웹어셈블리를 실행할 때 사용하는 실험적인 모듈입니다.

### 4) fs (●●●)

동기는 딱 한번 or 초기화 / 서버 실행 된 이후 쓰면 안됨

스트리밍 하면 메모리를 아낄 수 있다.

공문 연결?

fs.existsSync

fs.stat

---

Reference.

- https://nodejs.org/en/docs
- https://thebook.io/080334/0122/
- https://nodejs.org/api/crypto.html
- https://www.npmjs.com/package/crypto-js (SHA512(단반향), AES(대칭), RSA(비대칭) 사용 추천)
- https://stackoverflow.com/questions/48698234/node-js-spawn-vs-execute
